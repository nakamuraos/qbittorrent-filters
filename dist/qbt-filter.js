"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const T=1,f="args",u="ERROR#GETOPT: ";function h(n){throw new Error(u+n)}function C(n){const e={};return Object.entries(n).reduce((i,[t,r])=>(typeof r=="object"&&r.key&&(i[r.key]=t),i),e)}function L(n,e){if(!/^--?[a-zA-Z]/.test(e))return null;if(e.startsWith("--"))return[e.replace(/^--/,"")];const i=C(n);return e.replace(/^-/,"").split("").map(t=>i[t]||t)}function y(n){const e={[n.activeOption]:n.optionArgs};return Object.assign(n,{activeOption:"",remainingArgs:0,optionArgs:[],isMultiple:!1}),e}function j(n){const e={};return Object.entries(n).reduce((i,[t,r])=>(Array.isArray(r)&&r.length===1&&t!==f?i[t]=r[0]:i[t]=[...r],i),e)}function $(n,e){if(n._meta_&&typeof n._meta_=="object"){const{args:i=0,minArgs:t=0,maxArgs:r=0}=n._meta_;let s=0,a=null;Array.isArray(e[f])&&e[f].length>0&&(s=e[f].length),i&&s!==i&&(a=`${i} positional arguments are required, but ${s} were provided`),t&&s<t&&(a=`At least ${t} positional arguments are required, but ${s} were provided`),r&&s>r&&(a=`Max allowed positional arguments is ${r}, but ${s} were provided`),a&&h(a)}Object.entries(n).forEach(([i,t])=>{if(!(!t||typeof t!="object")&&!(!e[i]&&!t.mandatory&&!t.required)&&((t.mandatory||t.required)&&!e[i]&&h(`Missing option: "--${i}"`),t.args&&t.args!=="*")){const r=parseInt(String(t.args)),s=e[i]?e[i].length:0;r>0&&r!==s&&h(`Option "--${i}" requires ${r} arguments, but ${s} were provided`)}})}function x(n,e){Object.entries(n).forEach(([i,t])=>{if(!(!t||typeof t!="object")&&"default"in t&&!(i in e)){const r=Array.isArray(t.default)?t.default:[t.default];e[i]=r.map(s=>typeof s=="boolean"?s:String(s))}})}function S(n={},e){const i=e.slice(2),t={},r=[],s={activeOption:"",remainingArgs:0,optionArgs:[],isMultiple:!1};return i.forEach(a=>{const o=L(n,a);if(!o){if(s.activeOption)if(s.optionArgs.push(a),s.remainingArgs--,!s.remainingArgs||s.isMultiple){const c=s.isMultiple,l=y(s);Object.entries(l).forEach(([d,g])=>{c&&t[d]&&(l[d]=t[d].concat(g))}),Object.assign(t,l)}else t[s.activeOption]=s.optionArgs;else r.push(a);return}o.forEach(c=>{["h","help"].includes(c)&&h("help");let l=n[c];if(!l){h(`Unknown option: "${a}"`);return}typeof l=="boolean"&&(l={});const d=!!l.multiple;t[c]&&!d&&h(`Option "--${c}" provided many times`);let g=l.args;if(g==="*"&&(g=1/0),s.activeOption){const m=y(s);Object.entries(m).forEach(([b,I])=>{t[b]&&d&&(m[b]=t[b].concat(I))}),Object.assign(t,m)}if(!g&&!d){t[c]=[!0];return}Object.assign(s,{activeOption:c,remainingArgs:g||0,optionArgs:[],isMultiple:d}),d||(t[c]=[!0])})}),r.length&&(t[f]=r),x(n,t),$(n,t),j(t)}function B(n,e){const i=["USAGE: node "+e+" [OPTION1] [OPTION2]... arg1 arg2...","The following options are supported:"],t=[];Object.entries(n).forEach(([a,o])=>{if(a==="_meta_")return;if(typeof o!="object"||!o){t.push(["  --"+a,""]);return}let c=" ";o.multiple&&(o.args=1);const l=+(o.args||0);if(o.args==="*")c+="<ARG1>...<ARGN>";else for(let d=0;d<l;d++)c+="<ARG"+(d+1)+"> ";t.push(["  "+(o.key?"-"+o.key+", --":"--")+a+c,(o.description||"")+(o.mandatory||o.required?" (required)":"")+(o.multiple?" (multiple)":"")+(o.default?' ("'+o.default+'" by default)':"")])});const r=t.reduce((a,o)=>Math.max(o[0].length,a),0),s=t.map(a=>{const o=a[0],c=a[1],l=new Array(r-o.length+1).join(" ");return(o+l+"	"+c).trimRight()});return i.concat(s).join(`
`)}function _(n){const e=[];return n.forEach(i=>{if(/^--?[a-zA-Z]+=/.test(i)){const t=i.split("=")[0],r=i.replace(t+"=","");e.push(t),e.push(r)}else e.push(i)}),e}function U(n){if(n.help)throw new Error('"--help" option is reserved and cannot be declared in a getopt() call');Object.values(n).forEach(e=>{if(!e||typeof e!="object"){console.warn('Boolean description of getopt() options is deprecated and will be removed in a future "stdio" release. Please, use an object definitions instead.');return}if(e.key==="h")throw new Error('"-h" option is reserved and cannot be declared in a getopt() call');e.mandatory&&console.warn('"mandatory" option is deprecated and will be removed in a future "stdio" release. Please, use "required" instead.')})}const q=(n,e=process.argv,i)=>{const{exitOnFailure:t=!0,throwOnFailure:r=!1,printOnFailure:s=!0}={};try{return U(n),S(n,_(e))}catch(a){if(!a.message.startsWith(u))throw a;const o=e[1].split("/").pop()||"program",c=(a.message.replace(u,"")+`
`+B(n,o)).trim();if(s&&console.warn(c),t&&process.exit(a.message===u+"help"?0:T),r)throw new Error(c);return null}},O="Thunder,XL0012,BitComet,XunLei,Xfplay,danda,anacrolix,devel,dt/torrent,unknown",p=q({url:{key:"u",description:"URL of qBittorrent without 'http://' or 'https://'",default:process.env.URL||"127.0.0.1",args:1},port:{key:"p",description:"Port of qBittorrent",default:process.env.PORT||8080,args:1},username:{key:"U",description:"User to auth qBittorrent.",default:process.env.USERNAME||!1,args:1},password:{key:"P",description:"Password to auth qBittorrent. Leave blank to disable auth.",default:process.env.PASSWORD||!1,args:1},ssl:{key:"s",description:'Use https protocol ("http" by default)',default:process.env.SSL==="true"||!1},"time-interval":{key:"t",description:"Time interval in seconds between filter checks",default:process.env.TIME_INTERVAL||10,args:1},"time-clear":{key:"c",description:"Time interval in hours to clear banned peer list, 0 = disable",default:process.env.TIME_CLEAR||"0",args:1},"clear-immediately":{key:"ci",description:"Clear immediately banned peer list",default:process.env.CLEAR_IMMEDIATELY==="true"||!1},watch:{key:"w",description:"Watch all peers (output to sdtout)",default:process.env.WATCH==="true"||!1},"block-clients":{key:"x",description:"Blocks clients unconditionally regardless of leeching status",default:process.env.BLOCK_CLIENTS==="true"||!1},"block-list":{key:"b",description:"Blocks clients conditionally with wildcards",default:process.env.BLOCK_LIST||O,args:"*"},delimiter:{description:"Delimiter marks the beginning or end of a wildcard of list",default:process.env.DELIMITER||",",args:1},dry:{description:"Dry run for test",default:process.env.DRY==="true"||!1},debug:{description:"Print detail error logs",default:process.env.DEBUG==="true"||!1}}),w=async n=>{await new Promise(e=>setTimeout(e,n))},E=n=>n.toUpperCase().split("").map(e=>String.fromCodePoint(e.charCodeAt(0)+127397)).join("");class A{constructor(e){this.cookie=void 0,this.baseURL="",this.options={},this.commonHeaders={},this.bannedIPs="",this.options=e,typeof e["block-list"]=="string"&&(this.options["block-list"]=e["block-list"].split(e.delimiter).map(i=>i.trim())),this.reset()}async reset(){this.cookie=void 0,this.baseURL=`${this.options.ssl?"https":"http"}://${this.options.url}:${this.options.port}`,this.commonHeaders={Host:`${this.options.url}:${this.options.port}`,Origin:this.baseURL,Pragma:"no-cache",Referer:this.baseURL+"/","Accept-Encoding":"gzip, deflate, br"},this.bannedIPs=""}async init(){this.options.username&&this.options.password?await this.getCookie():this.logging("No auth required. Ignored get cookie."),this.logging("Fetching banned IPs..."),await this.getBannedIPs()}async getCookie(){const e=await this.POST(`${this.baseURL}/api/v2/auth/login`,`username=${this.options.username}&password=${this.options.password}`).then(i=>i.headers.get("set-cookie"));e&&(this.cookie=e.match(/(.*?);/)[1],this.logging("Cookie:",this.cookie))}async getBannedIPs(){let e=!0;do{const i=await this.getConfigs();if(i)return e=!1,this.bannedIPs=i.banned_IPs,this.logging("Total",this.bannedIPs.trim().split(`
`).filter(t=>!!t).length,"IPs banned."),this.bannedIPs;this.logging("Get banned IPs failed. Retrying in 5s..."),await w(5e3)}while(e)}async getConfigs(){return await this.GET(`${this.baseURL}/api/v2/app/preferences`)}async setConfigs(e){this.options.dry||await this.POST(`${this.baseURL}/api/v2/app/setPreferences`,`json=${JSON.stringify(e)}`)}async getAllTorrents(){const e=await this.GET(`${this.baseURL}/api/v2/sync/maindata`);return this.options.debug&&this.logging("Total",Object.keys((e==null?void 0:e.torrents)||{}).length,"torrents."),(e==null?void 0:e.torrents)||{}}async getPeers(e){return await this.GET(`${this.baseURL}/api/v2/sync/torrentPeers?hash=${e}`)}async banPeers(e=[]){const i=()=>{e.forEach(([r,s])=>{this.logging("Banned",r,s.connection,s.client,s.peer_id_client,E(s.country_code),s.country)})};(this.options.dry||await this.POST(`${this.baseURL}/api/v2/transfer/banPeers`,`peers=${e.map(([r])=>r).join("|")}`).then(()=>!0))&&i()}async clearBannedPeers(){this.options.dry||await this.POST(`${this.baseURL}/api/v2/torrents/clearBannedPeers`),this.bannedIPs="",this.logging("Cleared banned peers.")}async filter(){const e=await this.getAllTorrents(),i=Object.entries(e).filter(([,s])=>s.num_leechs>0);this.options.debug&&this.logging("Monitoring",i.length,"active torrents.");let t=0;const r=[];for(const[s,a]of i){const o=await this.getPeers(s);o?Object.entries(o.peers).forEach(async([c,l])=>{l.client&&t++,l.client&&this.options["block-list"].findIndex(d=>!!l.client.match(new RegExp(d,"gmi"))||!!l.peer_id_client.match(new RegExp(d,"gmi")))>0&&r.push([c,l])}):this.logging(a.name,"Get list of peers failed")}this.options.debug&&this.logging("Total",t,"peers filtered."),r.length&&(await this.banPeers(r),await this.setConfigs({banned_IPs:[...this.bannedIPs.split(`
`).filter(s=>!!s),...r.map(([,s])=>s.ip).filter(s=>!this.bannedIPs.includes(s))].join(`
`)}),await this.getBannedIPs())}async GET(e,i=1){return await fetch(e,{headers:{...this.commonHeaders,Accept:"application/json",Cookie:this.cookie}}).then(async t=>{if(t.status===403)if(this.options.username&&this.options.password){const r=await t.text();if(r.includes("Your IP address has been banned")&&(this.logging(r),this.logging("Please check username/password, restart qBittorrent and retry."),process.exit(1)),!t.url.includes("/login")&&i<3)return this.logging("Cookie expired. Fetching new cookie..."),await this.getCookie(),await this.GET(e,++i);this.logging("The username or password are not correct. Exiting..."),process.exit(1)}else this.logging("qBittorrent need auth but the username and password are not configured. Exiting..."),process.exit(1);if(t.status!==200){this.options.debug&&(this.logging(t),this.logging(await t.text()));return}return await t.json()}).catch(this.logging)}async POST(e,i,t=1){return await fetch(e,{method:"POST",headers:{...this.commonHeaders,"Content-Type":"application/x-www-form-urlencoded",Cookie:this.cookie},body:i}).then(async r=>{if(r.status===403)if(this.options.username&&this.options.password){const s=await r.text();if(s.includes("Your IP address has been banned")&&(this.logging(s),this.logging("Please check username/password, restart qBittorrent and retry."),process.exit(1)),!r.url.includes("/login")&&t<3)return this.logging("Cookie expired. Fetching new cookie..."),await this.getCookie(),await this.POST(e,i,++t);this.logging("The username or password are not correct. Exiting..."),process.exit(1)}else this.logging("qBittorrent need auth but the username and password are not configured. Exiting..."),process.exit(1);return r}).catch(this.logging)}logging(...e){var i;e[0]instanceof Error&&!((this==null?void 0:this.options)||p).debug&&(e=["[ERROR]",((i=e[0].cause)==null?void 0:i.message)||e[0].message]),console.log(`[${new Date().toISOString()}]`,...e)}}let R=null,P=new Date;const k=async()=>{const n=new A(p);n.logging(`Start filter with options
`,p),p["clear-immediately"]&&await n.clearBannedPeers(),await n.init(),await n.filter(),await w(+p["time-interval"]*1e3),R=setInterval(()=>{n.filter(),+p["time-clear"]>0&&new Date>new Date(P.getTime()+ +p["time-clear"]*60*60*1e3)&&(n.clearBannedPeers(),P=new Date)},+p["time-interval"]*1e3)};k();process.on("SIGINT",()=>{clearInterval(R),console.log("Exited."),process.exit()});exports.Filter=A;exports.country2flag=E;exports.defaultBlockList=O;exports.delay=w;exports.main=k;exports.options=p;
